#[[.rst:
BBuildEnv
---------

The module BBuildEnv provides a CMake build environment similar to Boost.Build with functions and macros 
to access other external SDKs including AdobeSDK, CodeMeter, CUDASamples, Intel Performance Libraries, OfxSDK, and VLC 
not yet supported by CMake natively. 

This module also provides some system information not yet available by CMake.  

How to Use
^^^^^^^^^^

Include the following statement(s) in your top-level CMakeLists.txt to load this module 
and its submodules.  The modification of CMAKE_MODULE_PATH makes a set of new or patched Find module available 
as well and is therefore the recommended way to include BBuildEnv::

  set( CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/CMakeBuild/cmake/modules" )
  # ... some other CMake statements ...
  include( BBuildEnv )

Projects without the need to modify their CMAKE_MODULE_PATH to get access to the supplemental/patched Find modules 
may prefer the following include statement::

  include( "${CMAKE_SOURCE_DIR}/CMakeBuild/cmake/modules/BBuildEnv.cmake" )


Reserved Identifiers
^^^^^^^^^^^^^^^^^^^^

Avoiding name clashes in CMakeLists.txt or project specific cmake files all projects including BBuildEnv.cmake 
are advised not to use CMake variables, functions or macros starting with::

  _bb_, bb_, BB_, _BB_, BBuildEnv, _BBuildEnv


#]]

#BBuildEnv_DISABLE_PYTHON_DETECTION

if( NOT CMAKE_VERSION VERSION_LESS 3.10 )
  include_guard( GLOBAL )
endif()

macro( _bb_set_bbuildenv_version version_ )
  if( DEFINED BBuildEnv_VERSION )
    if( NOT BBuildEnv_VERSION VERSION_EQUAL ${version_} )
      message( STATUS "Updating BBuildEnv ${BBuildEnv_VERSION} to ${version_}" )
      set( BBuildEnv_VERSION ${version_} CACHE INTERNAL "BBuildEnv version" )
    endif() 
  endif()
  set( BBuildEnv_VERSION ${version_} CACHE INTERNAL "BBuildEnv version" ) 
endmacro()
#
# Internal macro to extract the CXX compiler's <major>.<minor> version.
#
macro( _bb_get_cxx_compiler_version_major_minor version_major_minor_ )
  string( REGEX REPLACE "([0-9]+)\\.([0-9]+)([0-9.]+)?" "\\1.\\2" ${version_major_minor_} ${CMAKE_CXX_COMPILER_VERSION} )
endmacro()

macro( bb_get_home_dir home_dir_ )
  if( CMAKE_HOST_WIN32 )
    # Force forward slashes on Windows
    file( TO_CMAKE_PATH "$ENV{USERPROFILE}" ${home_dir_} )
  else()
    set( ${home_dir_} "$ENV{HOME}" )
  endif()
endmacro()


macro( bb_set_home_dir home_dir_ )
  # backward compatibility
  bb_get_home_dir( ${home_dir_} )
endmacro()



function( bb_get_binary_tool_dir tool_dir_ )
  # Location to store scripts and programs generated by CMake to support the build.
  set( _tool_dir "${CMAKE_BINARY_DIR}/tools" )
  if( NOT EXISTS "${_tool_dir}" )
    file( MAKE_DIRECTORY "${_tool_dir}" )
  endif()
  set( ${tool_dir_} "${_tool_dir}" PARENT_SCOPE )
endfunction()


macro( bb_check_build_type )
  # message( STATUS "bb_check_build_type(): entering" )
  if( CMAKE_VERSION VERSION_LESS 3.9 )
    # Define property GENERATOR_IS_MULTI_CONFIG if it does not exist.
    get_property( _bb_have_generator_is_multi_config GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG DEFINED )
    if( NOT _bb_have_generator_is_multi_config )
      # message( STATUS "bb_check_build_type(): global property GENERATOR_IS_MULTI_CONFIG is undefined." )
      # Property GENERATOR_IS_MULTI_CONFIG is not available
      define_property( GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG
                       BRIEF_DOCS "True when using a multi-configuration generator."
                       FULL_DOCS "True when using a multi-configuration generator. Builtin property of CMake 3.9.0 or higher." )
      if( MSVC OR XCODE )
        set_property( GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG 1 )
      else()
        set_property( GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG 0 )
      endif()
    endif()
    unset( _bb_have_generator_is_multi_config )
  endif()
  get_property( _bb_generator_is_multi_config GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG )
  # message( STATUS "bb_check_build_type(): GENERATOR_IS_MULTI_CONFIG=${_bb_generator_is_multi_config}" )
  if( NOT _bb_generator_is_multi_config )
    # set default CMAKE_BUILD_TYPE to Release if not set
    if( NOT CMAKE_BUILD_TYPE )
      set( CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel." FORCE )
    endif()
  endif()
  unset( _bb_generator_is_multi_config )
  # message( STATUS "bb_check_build_type(): leaving" )
endmacro( bb_check_build_type )


macro( bb_multithreading )
  if( TARGET Threads::Threads )
    message( FATAL_ERROR "bb_multithreading(): target Threads::Threads already exists. Please contact technical support." )
  endif()
  if( MINGW )
    # MinGW may be a native compiler or a cross compiler.
    find_package( Threads REQUIRED )
    #add_compile_options( -mthreads )
    #message( STATUS "bb_multithreading(): mingw detected, add_compile_options: -mthreads" )
    get_target_property( _bb_mt_prop_value Threads::Threads INTERFACE_COMPILE_OPTIONS )
    if( _bb_mt_prop_value )
      if( NOT _bb_mt_prop_value STREQUAL "-mthreads" ) 
        message( FATAL_ERROR "bb_multithreading(): target Threads::Threads has unexpected INTERFACE_COMPILE_OPTIONS: ${_bb_mt_prop_value}" )
      endif()
    else()
      set_target_properties( Threads::Threads PROPERTIES INTERFACE_COMPILE_OPTIONS "-mthreads" )
    endif()
    unset( _bb_mt_prop_value )
  elseif( CMAKE_CROSSCOMPILING )
    find_package( Threads REQUIRED )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Cray" )
    find_package( Threads REQUIRED ) 
  else()
    if( CMAKE_SYSTEM_NAME STREQUAL "Linux" )
      # Add interface compile/link option -pthread
      set( THREADS_PREFER_PTHREAD_FLAG ON )
    endif()
    find_package( Threads REQUIRED )
    if( CMAKE_SYSTEM_NAME STREQUAL "Linux" )
      # A compile option -pthread bound to all enabled languages won't work if CUDA is enabled as a programming language (tested with cmake 3.9.1).
      # Since NVCC does not understand -pthread, the compile option must be bound to C and CXX.
      get_target_property( _bb_mt_prop_value Threads::Threads INTERFACE_COMPILE_OPTIONS )
      if( _bb_mt_prop_value )
        if( _bb_mt_prop_value STREQUAL "-pthread" ) 
          set_target_properties( Threads::Threads PROPERTIES INTERFACE_COMPILE_OPTIONS $<$<OR:$<COMPILE_LANGUAGE:CXX>,$<COMPILE_LANGUAGE:C>>:-pthread> )
        endif()
      endif()
      unset( _bb_mt_prop_value )
    endif()
  endif()
endmacro( bb_multithreading )


macro( bb_enable_warnings )
  unset( _bb_warning_options )        # in case the calling context has defined it.

  _bb_enable_warnings_helper( _bb_warning_options ${ARGN} )

  if( DEFINED _bb_warning_options )
    message( STATUS "bb_enable_warnings: ${toolset} -> updating warnings flags: ${_bb_warning_options}" )
    foreach( _bb_warning_opt IN LISTS _bb_warning_options )
      if( MSVC )
        # MSVC generator does not support the generator expression COMPILE_LANGUAGE yet.
        string( APPEND CMAKE_CXX_FLAGS " ${_bb_warning_opt}" )
        string( APPEND CMAKE_C_FLAGS " ${_bb_warning_opt}" )
      else()
        add_compile_options( $<$<OR:$<COMPILE_LANGUAGE:CXX>,$<COMPILE_LANGUAGE:C>>:${_bb_warning_opt}> )
      endif()
    endforeach()      
    unset( _bb_warning_options )
  endif()    
endmacro()

function( _bb_enable_warnings_helper warning_options_ )
  #message( STATUS "_bb_enable_warnings_helper(): ${warning_options_} ARGC=${ARGC} ${ARGN}" )

  # Translate CMAKE_CXX_COMPILER_ID to a string which compares easily with toolset -> gcc, msvc, clang.
  if( CMAKE_CXX_COMPILER_ID STREQUAL "GNU" )
    set( _bb_warning_compiler_id "gcc" )
  elseif( CMAKE_CXX_COMPILER_ID MATCHES "^(AppleClang|Clang)$" )
    set( _bb_warning_compiler_id "clang" )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "MSVC" )
    set( _bb_warning_compiler_id "msvc" )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Intel" )
    set( _bb_warning_compiler_id "intel" )
    if( APPLE )
      # No support for intel yet.
      return() 
    endif()
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Cray" )
    set( _bb_warning_compiler_id "cray" )
    return()    
  else()
    # Not a compiler ID we have support for.
    return()
  endif()
 
  # Unset a few variables the logic below depends on. The calling context may have defined them.
  unset( _bb_warning_options )        
  unset( _bb_tmp_list_var )
  
  if( ${ARGC} GREATER 1 )
    set( _bb_tmp_list_var "${ARGN}" )
    # Analyze the first argument it may be a toolset, warnings-as-errors or a warning option.
    list( GET _bb_tmp_list_var 0 _arg1 )
    
    if( "${_arg1}" MATCHES "^(gcc|clang|msvc|intel)" )
      #message( STATUS "bb_enable_warnings(): found toolset argument ${ARGV0}" )
      if( "${_arg1}" MATCHES "^([a-z]+)-([0-9.]+)" )
        # strip version suffix; e.g. gcc-4.8 -> gcc
        set( _bb_warning_toolset         "${CMAKE_MATCH_1}" )
        set( _bb_warning_toolset_version "${CMAKE_MATCH_2}" )
      else()
        set( _bb_warning_toolset         "${_arg1}" )
        # Fake a version matching the current compiler version which simplifies the logic below.
        if( DEFINED bb_compiler_version_major_minor )
          set( _bb_warning_toolset_version "${bb_compiler_version_major_minor}" )
        else()
          _bb_get_cxx_compiler_version_major_minor( _bb_warning_toolset_version )
        endif()
      endif()
      
      if( ( NOT _bb_warning_toolset STREQUAL _bb_warning_compiler_id ) OR ( NOT _bb_warning_toolset_version VERSION_EQUAL bb_compiler_version_major_minor ) )
        # No match for current CXX compiler
        # message( STATUS "_bb_enable_warnings_helper(): no match for current compiler" )
        return()
      endif()
      
      # Drop the toolset from the list of arguments to be processed later on
      list( REMOVE_AT _bb_tmp_list_var 0 )
    endif()
  endif()
  
  if( CMAKE_CXX_COMPILER_ID MATCHES "^(AppleClang|Clang)$" )
    if( NOT XCODE )
      set( _bb_warning_options -Wall )
    endif()
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "GNU" )
    set( _bb_warning_options -Wall -fdiagnostics-show-option )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "MSVC" )
    # Do we have to override the warning level?
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Intel" )
    # Do we have to override the warning level on Windows/MSVC?
    if( ( NOT MSVC ) AND ( NOT XCODE ) )
      set( _bb_warning_options -Wall )
    endif()
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Cray" )
    # Do we have to override the warning level?    
  endif()
  
  #message( STATUS "bb_enable_warnings(): processing additional warning options ${_bb_tmp_list_var}" )
  foreach( _bb_v IN LISTS _bb_tmp_list_var )
    #message( STATUS "processing ${_bb_v}" )
    if( ${_bb_v} STREQUAL "warnings-as-errors" )
      if( CMAKE_CXX_COMPILER_ID MATCHES "^(GNU|AppleClang|Clang)$" )
        list( APPEND _bb_warning_options "-Werror" )
      elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Intel" )
        if( MSVC )
          list( APPEND _bb_warning_options "/WX" )
        else()
          list( APPEND _bb_warning_options "-Werror" )
        endif()          
      elseif( CMAKE_CXX_COMPILER_ID STREQUAL "MSVC" )
        list( APPEND _bb_warning_options "/WX" )
      endif()
    else()
      list( APPEND _bb_warning_options "${_bb_v}" )
    endif()
  endforeach()
  
  if( DEFINED _bb_warning_options )
    if( MSVC )
      if( CMAKE_CXX_COMPILER_ID STREQUAL "Intel" )
        # Replace -XXX with /XXX avoiding the mix of both option specifications. 
        string( REPLACE "-Q" "/Q" _bb_warning_options "${_bb_warning_options}" )
      else()
        # Replace -XXX with /XXX avoiding the mix of both option specifications. 
        string( REPLACE "-" "/" _bb_warning_options "${_bb_warning_options}" )
      endif()
    endif()
    set( ${warning_options_} ${_bb_warning_options} PARENT_SCOPE )
  endif()
endfunction( _bb_enable_warnings_helper )


macro( bb_get_program_files_x86 program_files_x86_ )
  bb_get_env_icase( ${program_files_x86_} "ProgramFiles(x86)" TO_CMAKE_PATH )
endmacro()


macro( bb_get_program_files program_files_ )
  bb_get_env_icase( ${program_files_} "ProgramFiles" TO_CMAKE_PATH )
endmacro()


macro( bb_get_program_data program_data_ )
  bb_get_env_icase( ${program_data_} "ProgramData" TO_CMAKE_PATH )
endmacro()


function( bb_get_env_icase env_var_value_ env_var_ )
  unset( _path_conversion )
  if( ${ARGC} EQUAL 3 )
    set( _path_conversion ${ARGV2} )
    if( NOT ${_path_conversion} MATCHES "^(TO_CMAKE_PATH|TO_NATIVE_PATH)$" )
      message( FATAL_ERROR "illegal conversion ${_path_conversion} specified, use TO_CMAKE_PATH or TO_NATIVE_PATH" )
    endif()
  elseif( ${ARGC} GREATER 3 )
     message( FATAL_ERROR "too many arguments specified: ${ARGV}" )
  endif()
  unset( _env_var_value )
  if( DEFINED ENV{${env_var_}} )
    set( _env_var_value "$ENV{${env_var_}}" )
  else()
    # Mixed-case environment variable?
    string( TOUPPER "${env_var_}" _env_var_uc )
    if( NOT ${_env_var_uc} STREQUAL ${env_var_} )
      # Try uppercase environment variable to suit buildbot and possibly other python frameworks.
      if( DEFINED ENV{${_env_var_uc}} )
        set( _env_var_value "$ENV{${_env_var_uc}}" )
      endif()
    endif()
  endif()
  if( DEFINED _env_var_value )
    if( DEFINED _path_conversion )
      file( ${_path_conversion} "${_env_var_value}" _env_var_value )
    endif()
    set( ${env_var_value_} "${_env_var_value}" PARENT_SCOPE )
  else()
    # Should we assign -NOTFOUND instead?
    if( DEFINED ${env_var_value_} )
      unset( ${env_var_value_} PARENT_SCOPE )
    endif()
  endif()
endfunction()


function( _bb_find_proj_home proj_home_ home_dir_ )
  unset( _proj_home )
  if( DEFINED ENV{PROJ_HOME} )
    # message( STATUS "BBuildEnv: using environment variable PROJ_HOME=$ENV{PROJ_HOME}" )
    # Force forward slashes on Windows
    file( TO_CMAKE_PATH "$ENV{PROJ_HOME}" _proj_home )
    if( NOT EXISTS ${_proj_home} )
      message( FATAL_ERROR "\
  Environment variable PROJ_HOME=${_proj_home}
  points to a non-existing directory.
      " )
    endif()
  elseif( IS_DIRECTORY "${home_dir_}/projects" )
    set( _proj_home "${home_dir_}/projects" )
  #else()
  #  get_filename_component( _proj_home ${CMAKE_SOURCE_DIR}/.. REALPATH )
  endif()
  if( DEFINED _proj_home )
    set( ${proj_home_} "${_proj_home}" PARENT_SCOPE )
  endif()
endfunction()

#
# search path: $ENV{PROJ_HOME} ${CMAKE_SOURCE_DIR}/.. ${bb_home_dir}/projects
#
function( bb_set_external_dir dir_var_ dir_ )
  unset( _dir )
  set( _dir_required TRUE )
  
  if( ARGC GREATER 2 )
    # Process optional arguments
    foreach( _arg IN LISTS ARGN )
      if( _arg STREQUAL "OPTIONAL" )
        set( _dir_required FALSE )
      endif()
    endforeach()
  endif()
  
  if( IS_ABSOLUTE "${dir_}" )
    if( NOT EXISTS "${dir_}" )
      if( _dir_required )
        message( FATAL_ERROR "bb_set_external_dir(): ${dir_} does not exist." )
      endif()
    else()
      set( _dir "${dir_}" )
    endif()
  else()
    unset( _search_path ) 
    if( DEFINED ENV{PROJ_HOME} )
      file( TO_CMAKE_PATH "$ENV{PROJ_HOME}" _proj_home )
      list( APPEND _search_path "${_proj_home}" )
    endif()
    #list( APPEND _search_path "${CMAKE_CURRENT_SOURCE_DIR}/.." )
    get_filename_component( _dir_norm "${CMAKE_SOURCE_DIR}/.." REALPATH )
    list( APPEND _search_path "${_dir_norm}" )
    if( EXISTS "${bb_home_dir}/projects" )
      list( APPEND _search_path "${bb_home_dir}/projects" )
    endif()
    list( REMOVE_DUPLICATES _search_path )
    foreach( _path IN LISTS _search_path )
      if( EXISTS "${_path}/${dir_}" )
        set( _dir "${_path}/${dir_}" )
        break()
      endif()
    endforeach()
    if( NOT DEFINED _dir )
      if( _dir_required )
        message( FATAL_ERROR "bb_set_external_dir(): cannot find ${dir_} in ${_search_path}. You may use the environment variable PROJ_HOME to supplement the default search path." )
      endif()
    else()
      get_filename_component( _dir "${_dir}" REALPATH )
    endif()
  endif()
  if( DEFINED _dir )
    set( ${dir_var_} "${_dir}" PARENT_SCOPE )
  endif()
endfunction()

# 
# Mingw utilities
# 
include( ${CMAKE_CURRENT_LIST_DIR}/BBuildEnvMingw.cmake )

# 
# Additional system information
# 
macro( bb_get_python_script_path script_path_ script_dir_ script_name_ )
  if( PYTHONINTERP_FOUND )
    if( ${PYTHON_VERSION_STRING} VERSION_LESS 3.0 )
      set( ${script_path_} "${script_dir_}/${script_name_}.py" )
    else()
      set( ${script_path_} "${script_dir_}/${script_name_}3.py" )
    endif()
  else()
    message( FATAL_ERROR "bb_get_python_script_path(): configuration error: python interpreter not found, please contact technical support." )
  endif()
endmacro()
 
macro( bb_dump_cmake_system_info )
  message( STATUS "bb_dump_cmake_system_info() entering" )
  message( STATUS "CMAKE_COMMAND:               ${CMAKE_COMMAND}" )
  message( STATUS "CMAKE_VERSION:               ${CMAKE_VERSION}" )
  message( STATUS "CMAKE_ROOT:                  ${CMAKE_ROOT}" )
  message( STATUS "CMAKE_SOURCE_DIR:            ${CMAKE_SOURCE_DIR}" )
  message( STATUS "CMAKE_SIZEOF_VOID_P:         ${CMAKE_SIZEOF_VOID_P}" )
  
  if( MINGW )
    message( STATUS "MINGW:                     on" )
  endif()

  if( CMAKE_CROSSCOMPILING )
    message( STATUS "CMAKE_CROSSCOMPILING:      on" )
  endif()
  
  # target operating system: Linux, Windows, Darwin, Android
  message( STATUS "CMAKE_SYSTEM_NAME:           ${CMAKE_SYSTEM_NAME}" )
  message( STATUS "CMAKE_HOST_SYSTEM:           ${CMAKE_HOST_SYSTEM}" )
  message( STATUS "CMAKE_SYSTEM_VERSION:        ${CMAKE_SYSTEM_VERSION}" )
  
  # examples: x86_64 (ubuntu 16.04, macosx 10.12)
  #           AMD64 (windows 7 64-bit, -A x64, -A Win32)
  message( STATUS "CMAKE_SYSTEM_PROCESSOR:      ${CMAKE_SYSTEM_PROCESSOR}" )
  message( STATUS "CMAKE_HOST_SYSTEM_PROCESSOR: ${CMAKE_HOST_SYSTEM_PROCESSOR}" )
 
  if( CMAKE_HOST_APPLE )
    message( STATUS "CMAKE_HOST_APPLE:            on" )
  endif()
  if( CMAKE_HOST_UNIX )
    message( STATUS "CMAKE_HOST_UNIX:             on" )
  endif()
  if( CMAKE_HOST_WIN32 )
    message( STATUS "CMAKE_HOST_WIN32:            on" )
  endif()
  if( CMAKE_VERSION VERSION_GREATER_EQUAL 3.10.0 )
    cmake_host_system_information( RESULT os_name QUERY OS_NAME )
    cmake_host_system_information( RESULT os_release QUERY OS_RELEASE )
    cmake_host_system_information( RESULT os_version QUERY OS_VERSION )
    cmake_host_system_information( RESULT os_platform QUERY OS_PLATFORM )
    message( STATUS "OS_NAME:                     ${os_name}" )
    message( STATUS "OS_RELEASE:                  ${os_release}" )
    message( STATUS "OS_VERSION:                  ${os_version}" )
    message( STATUS "OS_PLATFORM:                 ${os_platform}" )
  endif()
  message( STATUS "CMAKE_PROGRAM_PATH:          ${CMAKE_PROGRAM_PATH}" )  
  message( STATUS "CMAKE_SYSTEM_PROGRAM_PATH:   ${CMAKE_SYSTEM_PROGRAM_PATH}" )
  message( STATUS "CMAKE_GENERATOR:             ${CMAKE_GENERATOR}" )
  if( CMAKE_CXX_COMPILER_LOADED )
    message( STATUS "CMAKE_CXX_COMPILER_LOADED:   on" )
  endif()
  # expected: GNU, Clang, AppleClang, MSVC,
  message( STATUS "CMAKE_CXX_COMPILER_ID:       ${CMAKE_CXX_COMPILER_ID}" )
  message( STATUS "CMAKE_CXX_COMPILER:          ${CMAKE_CXX_COMPILER}" )
  message( STATUS "CMAKE_CXX_COMPILER_VERSION:  ${CMAKE_CXX_COMPILER_VERSION}" )
  #message( STATUS "cxx compile features:        ${CMAKE_CXX_COMPILE_FEATURES}" )
  
  if( MSVC )
    message( STATUS "CMAKE_VS_PLATFORM_NAME:      ${CMAKE_VS_PLATFORM_NAME}" )
    message( STATUS "CMAKE_VS_PLATFORM_TOOLSET:   ${CMAKE_VS_PLATFORM_TOOLSET}" )
    message( STATUS "MSVC_VERSION:                ${MSVC_VERSION}" )
    if( CMAKE_CSharp_COMPILER_WORKS )
      message( STATUS "CMAKE_CSharp_COMPILER_ID:      ${CMAKE_CSharp_COMPILER_ID}" )
      message( STATUS "CMAKE_CSharp_COMPILER:         ${CMAKE_CSharp_COMPILER}" )
      message( STATUS "CMAKE_CSharp_COMPILER_VERSION: ${CMAKE_CSharp_COMPILER_VERSION}" )
    endif()
  endif()
  if( XCODE )
    if( CMAKE_Swift_COMPILER_ID )
      message( STATUS "CMAKE_Swift_COMPILER_ID:      ${CMAKE_Swift_COMPILER_ID}" )
      message( STATUS "CMAKE_Swift_COMPILER:         ${CMAKE_Swift_COMPILER}" )
      message( STATUS "CMAKE_Swift_COMPILER_VERSION: ${CMAKE_Swift_COMPILER_VERSION}" )
    endif()  
  endif()
  get_property( _bb_generator_is_multi_config GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG )
  if( _bb_generator_is_multi_config )
    message( STATUS "CMAKE_CONFIGURATION_TYPES:   ${CMAKE_CONFIGURATION_TYPES}" )
  else()
    message( STATUS "CMAKE_BUILD_TYPE:            ${CMAKE_BUILD_TYPE}" )
  endif()
  unset( _bb_generator_is_multi_config ) 
  #message( STATUS "bb_system_info:              ${bb_system_info}" )
  message( STATUS "bb_dump_cmake_system_info() leaving" )
endmacro( bb_dump_cmake_system_info )


function( _bb_query_linux_pkg_arch pkg_arch_ )
  if( bb_dpkg_cmd )
    execute_process( COMMAND ${bb_dpkg_cmd} --print-architecture
                     RESULT_VARIABLE _retv_child
                     OUTPUT_VARIABLE _pkg_arch
                     OUTPUT_STRIP_TRAILING_WHITESPACE )
    if( NOT _retv_child EQUAL 0 )
      message( FATAL_ERROR "${bb_dpkg_cmd} --print-architecture failed, please contact technical support." )
    endif()
    set( ${pkg_arch_} "${_pkg_arch}" PARENT_SCOPE )
  elseif( bb_rpm_cmd )
    execute_process( COMMAND ${bb_rpm_cmd} --eval "%_arch"
                     RESULT_VARIABLE _retv_child
                     OUTPUT_VARIABLE _pkg_arch
                     OUTPUT_STRIP_TRAILING_WHITESPACE )
    if( NOT _retv_child EQUAL 0 )
      message( FATAL_ERROR "${bb_rpm_cmd} --eval %_arch failed, please contact technical support." )
    endif()
  endif()
  if( DEFINED _pkg_arch )
    set( ${pkg_arch_} "${_pkg_arch}" PARENT_SCOPE )    
  endif()  
endfunction()

function( _bb_find_macosx_isysroot isysroot_ )
  if( CMAKE_HOST_APPLE )
    execute_process( COMMAND xcrun --sdk macosx --show-sdk-path
                     RESULT_VARIABLE _retv_child
                     OUTPUT_VARIABLE _isysroot
                     OUTPUT_STRIP_TRAILING_WHITESPACE )
    # message( STATUS "macosx isysroot discovery: retv_child=${_retv_child} ${_isysroot}" )
    if( _retv_child EQUAL 0 )
      set( ${isysroot_} ${_isysroot} PARENT_SCOPE )
    endif()
  endif()
endfunction()

function( _bb_query_system_info system_info_ )

  #message( STATUS "_bb_query_system_info: starting  system_info=${${system_info_}}" )
  if( DEFINED ${system_info_} )
    return()
  endif()

  #message( STATUS "BBuildEnv: collecting additional system information ..." )
  
  foreach( v _lsb_distro_name _lsb_distro_codename _lsb_distro_version _distro_pkg_fmt _distro_pkg_arch _isysroot )
    # message( STATUS "v = ${v}" )
    set( ${v} "none" )
  endforeach()
  
  set( _os_arch "x86_64" )
  
  if( CMAKE_HOST_WIN32 )
    # cmake host system: Windows-6.1.7601
    set( _system_info "windows" )
    if( CMAKE_HOST_SYSTEM MATCHES "[wW][A-Za-z]+-([0-9.]+)" )
      set( _lsb_distro_version "${CMAKE_MATCH_1}" )
    endif()
  elseif( CMAKE_HOST_APPLE )
    set( _system_info "macosx" )
    if( CMAKE_VERSION VERSION_GREATER_EQUAL 3.10.0 )
      # sw_vers -productVersion
      cmake_host_system_information( RESULT _lsb_distro_version QUERY OS_RELEASE )
      # sw_vers -buildVersion
      # cmake_host_system_information( RESULT _lsb_distro_version QUERY OS_VERSION )
    else()
      execute_process( COMMAND sw_vers -productVersion
                       OUTPUT_VARIABLE _lsb_distro_version
                       RESULT_VARIABLE _retv_child
                       OUTPUT_STRIP_TRAILING_WHITESPACE )    
      if( NOT _retv_child EQUAL 0 )
        message( WARNING "sw_vers -productVersion failed, please contact technical support." )
      endif()      
    endif()

    if( NOT CMAKE_CROSSCOMPILING )
      _bb_find_macosx_isysroot( _isysroot )
    endif()  
  elseif( CMAKE_HOST_UNIX )
    set( _system_info "linux" )
    if( CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "^(i686|x86)$" )
      set( _os_arch "x86" )
    endif()
    
    mark_as_advanced( bb_dpkg_cmd bb_bb_rpm_cmd bb_lsb_release_cmd )
    
    find_program( bb_dpkg_cmd "dpkg" )
    if( bb_dpkg_cmd )
      set( _distro_pkg_fmt "deb" )
    else()
      find_program( bb_rpm_cmd "rpm" )
      if( bb_rpm_cmd )
        set( _distro_pkg_fmt "rpm" )
      endif()
    endif()
    find_program( bb_lsb_release_cmd "lsb_release" )
    
    if( DEFINED ENV{CRAYOS_VERSION} )
      set( _lsb_distro_version $ENV{CRAYOS_VERSION} )
      set( _lsb_distro_name     "cray" )
      set( _lsb_distro_codename "none" )
    else()
      if( NOT bb_lsb_release_cmd )
        message( WARNING "BBuildEnv: lsb_release not found, no way to retrieve additional linux system information." )
        #return()
      else()
        execute_process( COMMAND ${bb_lsb_release_cmd} -is
                         RESULT_VARIABLE _retv_child
                         OUTPUT_VARIABLE _lsb_distro_name
                         OUTPUT_STRIP_TRAILING_WHITESPACE )
        if( NOT _retv_child EQUAL 0 )
          message( WARNING "${bb_lsb_release_cmd} -is failed, please contact technical support." )
        endif()
        execute_process( COMMAND ${bb_lsb_release_cmd} -cs
                         RESULT_VARIABLE _retv_child
                         OUTPUT_VARIABLE _lsb_distro_codename
                         OUTPUT_STRIP_TRAILING_WHITESPACE )
        if( NOT _retv_child EQUAL 0 )
          message( WARNING "${bb_lsb_release_cmd} -cs failed, please contact technical support." )
        endif()    
        execute_process( COMMAND ${bb_lsb_release_cmd} -rs
                         RESULT_VARIABLE _retv_child
                         OUTPUT_VARIABLE _lsb_distro_version
                         OUTPUT_STRIP_TRAILING_WHITESPACE )
        if( NOT _retv_child EQUAL 0 )
          message( WARNING "${bb_lsb_release_cmd} -rs failed, please contact technical support." )
        endif()
      endif()
    endif()
    
    _bb_query_linux_pkg_arch( _distro_pkg_arch )

    # convert distro name to lowercase 
    string( TOLOWER "${_lsb_distro_name}" _lsb_distro_name )
    # convert distro codename to lowercase
    string( TOLOWER "${_lsb_distro_codename}" _lsb_distro_codename )
    # suse does not seem to provide a reasonable codename via lsb_release -cs and issues "n/a".  Such
    # a string is likely to cause problems if used as filename component or evaluated in a similar context.
    # Hence, it's replace by none.
    if( _lsb_distro_codename STREQUAL "n/a" )
      set( _lsb_distro_codename "none" )
    endif()
  endif()
  if( _lsb_distro_version STREQUAL "none" )
    set( _lsb_distro_version "0.0"  )
  endif()
  list( APPEND _system_info ${_os_arch} ${_lsb_distro_name} ${_lsb_distro_codename} ${_lsb_distro_version} ${_distro_pkg_fmt} ${_distro_pkg_arch} ${_isysroot} )
  set( ${system_info_} "${_system_info}" CACHE INTERNAL "additional system information" )
endfunction( _bb_query_system_info )

function( _bb_get_platform_dir platform_dir_ )
  if( CMAKE_CROSSCOMPILING )
    if( CMAKE_SYSTEM_PROCESSOR MATCHES "^(i686|x86)$" )
      set( _platform_dir "x86" )
    elseif( CMAKE_SYSTEM_PROCESSOR MATCHES "^(x86_64|AMD64)$" )
      set( _platform_dir "x86_64" )
    else()
      set( _platform_dir "${CMAKE_SYSTEM_PROCESSOR}" )
    endif()  
  else()
    if( CMAKE_SIZEOF_VOID_P EQUAL 8 )
      set( _platform_dir "x86_64" )
    else()
      set( _platform_dir "x86" )
    endif()
  endif()
  set( ${platform_dir_} "${_platform_dir}" PARENT_SCOPE )
endfunction()

function( _bb_get_toolset_subdir toolset_subdir_ compiler_version_ )
  unset( _toolset_subdir )
  # Assume cmake is able to figure out CMAKE_CXX_COMPILER_ID for all compilers including cross compilers.
  if( CMAKE_CXX_COMPILER_ID MATCHES "^(AppleClang|Clang)$" )
    set( _toolset_subdir "clang-${compiler_version_}" )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "GNU" )
    set( _toolset_subdir "gcc-${compiler_version_}" )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "MSVC" )
    set( _toolset_subdir "msvc-${compiler_version_}" )
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Intel" )
    set( _toolset_subdir "intel-${compiler_version_}" )
    if( MSVC )
      if( NOT DEFINED bb_generator_alias )
        message( FATAL_ERROR "MSVC defined but bb_generator_alias is undefined, looks like an internal bug. Please contact technical support." )
      else()
        set( _toolset_subdir "intel-${compiler_version_}-${bb_generator_alias}" )
      endif()
    endif()
  elseif( CMAKE_CXX_COMPILER_ID STREQUAL "Cray" )
    set( _toolset_subdir "cray-${compiler_version_}" )
  else()
    message( FATAL_ERROR "unsupported CMAKE_CXX_COMPILER_ID=${CMAKE_CXX_COMPILER_ID}, please contact technical support." )
  endif()
  if( MINGW )
    # MinGW is either a cross compiler or a native compiler.
    set( _toolset_subdir "gcc-mingw-${compiler_version_}" )
  elseif( CMAKE_CROSSCOMPILING )
    message( FATAL_ERROR "no support for this type of cross compiler, please contact technical support." )
  endif()
  if( DEFINED _toolset_subdir )
    set( ${toolset_subdir_} "${_toolset_subdir}" PARENT_SCOPE )
  endif()
endfunction()

function( bb_get_os_arch os_arch_ )
  list( GET bb_system_info 1 _os_arch )
  set( ${os_arch_} "${_os_arch}" PARENT_SCOPE )
endfunction()

function( bb_get_target_arch target_arch_ )
  list( GET bb_system_info 1 _target_arch )
  if( MSVC )
    if( CMAKE_VS_PLATFORM_NAME STREQUAL "x64" )
      set( _target_arch "x86_64" )
    elseif( CMAKE_VS_PLATFORM_NAME STREQUAL "Win32" )
      set( _target_arch "x86" )
    endif()
  elseif( MINGW )
    if( CMAKE_SYSTEM_PROCESSOR MATCHES "^(x86_64|amd64|AMD64)$" )
      set( _target_arch "x86_64" )
    else()
      set( _target_arch "x86" )
    endif()
  elseif( CMAKE_CROSSCOMPILING )
    # tbd
    set( _target_arch "${CMAKE_SYSTEM_PROCESSOR}" )
  endif()
  set( ${target_arch_} "${_target_arch}" PARENT_SCOPE )
endfunction()

function( bb_get_linux_distro_name distro_name_ )
  list( GET bb_system_info 2 _distro_name )
  set( ${distro_name_} "${_distro_name}" PARENT_SCOPE )
endfunction()

function( bb_get_os_codename os_codename_ )
  list( GET bb_system_info 3 _os_codename )
  set( ${os_codename_} "${_os_codename}" PARENT_SCOPE )
endfunction()

function( bb_get_os_version os_version_ )
  list( GET bb_system_info 4 _os_version )
  set( ${os_version_} "${_os_version}" PARENT_SCOPE )
endfunction()

function( bb_get_linux_pkg_fmt pkg_fmt_ )
  list( GET bb_system_info 5 _pkg_fmt )
  set( ${pkg_fmt_} "${_pkg_fmt}" PARENT_SCOPE )
endfunction()

function( bb_get_linux_pkg_arch pkg_arch_ )
  list( GET bb_system_info 6 _pkg_arch )
  set( ${pkg_arch_} "${_pkg_arch}" PARENT_SCOPE )
endfunction()

function( bb_get_isysroot isysroot_ )
  list( GET bb_system_info 7 _isysroot )
  set( ${isysroot_} "${_isysroot}" PARENT_SCOPE )
endfunction()

function( bb_dump_target_properties target_ prop1_ )
  set( _prop_list ${prop1_} )
  list( APPEND _prop_list ${ARGN} )
  list( LENGTH _prop_list _prop_list_len )
  message( STATUS "bb_dump_target_properties: len=${_prop_list_len} ${_prop_list}" )
  foreach( _prop ${_prop_list} )
    get_target_property( _prop_value ${target_} ${_prop} )
    if( _prop_value )
      message( STATUS "bb_dump_target_properties: ${target_}: ${_prop}=${_prop_value}" )
    endif()  
  endforeach()
  message( STATUS "bb_dump_target_properties: leaving" )
endfunction()

function( bb_get_imp_targets_from_components target_list_ target_prefix_ config_ comp1_ )
  set( _comp_list ${comp1_} ${ARGN} )
  unset( _target_list )
  #message( STATUS "bb_get_imp_targets_from_components(): ${_comp_list}" )
  string( TOUPPER "${config_}" _config_uc )
  set( _target_prop_list INTERFACE_LINK_LIBRARIES_${_config_uc} INTERFACE_LINK_LIBRARIES IMPORTED_LINK_INTERFACE_LIBRARIES_${_config_uc} IMPORTED_LINK_INTERFACE_LIBRARIES )
  foreach( _comp IN LISTS _comp_list )
    set( _target_name ${target_prefix_}${_comp} )
    list( APPEND _target_list ${_target_name} )
    foreach( _target_prop IN LISTS _target_prop_list )
      get_target_property( _prop_value ${_target_name} ${_target_prop} )
      #message( STATUS "${_target_name} ${_target_prop} -> _prop_value=${_prop_value}" )
      if( _prop_value )
        #message( STATUS "_bb_get_qt5_dlls: Qt5::${_comp}: INTERFACE_LINK_LIBRARIES=${_prop_value}" )
        foreach( _lnk_lib ${_prop_value} )
          if( _lnk_lib MATCHES "^${target_prefix_}[a-zA-Z]" )
            list( APPEND _target_list ${_lnk_lib} )
          endif()
        endforeach()
        break()
      endif()
    endforeach()
  endforeach()
  if( DEFINED _target_list )
    list( REMOVE_DUPLICATES _target_list )
    set( ${target_list_} ${_target_list} PARENT_SCOPE )
  endif()
endfunction()

# Optional argument: NO_PDB_FILES
function( bb_get_dsos_from_imp_targets dso_list_ config_ target1_ )
  string( TOUPPER "${config_}" _config_uc )
  set( _target_list ${target1_} ${ARGN} )
  if( NO_PDB_FILES IN_LIST _target_list )
    set( _no_pdb_files TRUE )
    list( REMOVE_ITEM _target_list NO_PDB_FILES )
  else()
    set( _no_pdb_files FALSE )
  endif()
  unset( _bin_dir )
  unset( _dso_list )
  # Walk _target_list and collect paths to dlls.
  foreach( _target ${_target_list} )
    # "IMPORTED_LOCATION" "IMPORTED_LOCATION_RELEASE" "IMPORTED_LOCATION_DEBUG"
    get_target_property( _prop_value ${_target} IMPORTED_LOCATION_${_config_uc} )
    if( NOT _prop_value )
      message( WARNING "_bb_get_qt5_dlls(): no IMPORTED_LOCATION_${_configuration} for target ${_qt5_target}" )
      get_target_property( _prop_value ${_target} IMPORTED_LOCATION )
    endif()
    if( _prop_value )
      # Ignore any static libraries
      get_filename_component( _lib_ext ${_prop_value} EXT )
      if( WIN32 )
        if( NOT _lib_ext MATCHES "^\\.(dll|DLL)$" )
          continue()
        endif()
      elseif( APPLE )
        if( _lib_ext STREQUAL ".a" )
          continue()
        endif()      
      else()
        # Linux: extension may have a trailing version number.
        if( NOT _lib_ext MATCHES "^\\.so" )
          continue()
        endif()      
      endif()
      # message( STATUS "${_target}: IMPORTED_LOCATION_RELEASE=${_prop_value}" )
      if( NOT DEFINED _bin_dir )
        get_filename_component( _bin_dir ${_prop_value} DIRECTORY )
      endif()
      list( APPEND _dso_list ${_prop_value} )
      if( _config_uc STREQUAL "DEBUG" )
        if( WIN32 AND NOT ${_no_pdb_files} )
          # Add PDB file if available
          get_filename_component( _filenm ${_prop_value} NAME_WE )
          if( EXISTS "${_bin_dir}/${_filenm}.pdb" )
            list( APPEND _dso_list "${_bin_dir}/${_filenm}.pdb" )
          endif()
        endif()
      endif()
    endif()
  endforeach()
  if( DEFINED _dso_list )
    set( ${dso_list_} ${_dso_list} PARENT_SCOPE )
  endif()
endfunction()


function( bb_file action_ input_path_ output_path_ )

  if( "${action_}" STREQUAL "TO_SHORT_PATH" )
    if( NOT CMAKE_HOST_WIN32 )
      message( FATAL_ERROR "Short path conversion is only supported on Windows host systems." )
    endif()
  endif()
  
  if( "${action_}" MATCHES "^(TO_NATIVE_PATH|TO_SHORT_PATH)$" )
    if( CMAKE_HOST_WIN32 )      
      if( CMAKE_GENERATOR STREQUAL "MinGW Makefiles" )
        # Painful hack to get backslashes as the CMake generator mgwmake seems to enable Linux path conversion 
        # rather than Windows path conversion.
        # example: C:/Program Files -> C:/Program\ Files
        string( REPLACE "/" "\\" _native_path "${input_path_}" )
      else()
        file( TO_NATIVE_PATH "${input_path_}" _native_path )
      endif()
    else()
      file( TO_NATIVE_PATH "${input_path_}" _native_path )
    endif()
    # message( STATUS "input_path='${input_path_}' native_path='${_native_path}'" )
    if( "${action_}" STREQUAL "TO_NATIVE_PATH" )
      set( ${output_path_} "${_native_path}" PARENT_SCOPE )
    endif()
  endif()
  
  if( "${action_}" STREQUAL "TO_SHORT_PATH" )
    find_program( BB_SHELL_PROG "cmd.exe" )
    bb_file( TO_NATIVE_PATH "${BB_SHELL_PROG}" script_launcher )
    set( script_cmd_line "/c" )
  
    bb_get_binary_tool_dir( _tool_dir )
  
    if( NOT EXISTS "${_tool_dir}/get_short_path.cmd" )
      file( WRITE "${_tool_dir}/get_short_path.cmd" "@echo off\n" "echo %~s1\n" )
    endif()
    
    bb_file( TO_NATIVE_PATH "${_tool_dir}/get_short_path.cmd" cmd_script )
    string( APPEND script_cmd_line " ${cmd_script}" )
    string( APPEND script_cmd_line " \"${_native_path}\"" )
    #
    separate_arguments( script_args NATIVE_COMMAND "${script_cmd_line}" )
    # message( STATUS "Launching: ${script_launcher} ${script_args}" )
    execute_process( COMMAND "${script_launcher}" ${script_args} WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}" RESULT_VARIABLE retv OUTPUT_VARIABLE short_path OUTPUT_STRIP_TRAILING_WHITESPACE )

    if( retv EQUAL 0 )
      #message( STATUS "python interpreter (short path): ${short_path}" )
      set( ${output_path_} "${short_path}" PARENT_SCOPE )
    else()
      message( FATAL_ERROR "short path conversion failed: ${retv}, please contact technical support." )
    endif()
  endif()
endfunction()


# 
# Version file parsing utilities
#
include( ${CMAKE_CURRENT_LIST_DIR}/BBuildEnvVersionUtil.cmake )

#
# CPACK support
# 
include( ${CMAKE_CURRENT_LIST_DIR}/BBuildEnvCPack.cmake )

#
# BOOST SDK utilities
#
include( ${CMAKE_CURRENT_LIST_DIR}/BBuildEnvBoost.cmake )

#
# Qt5 utilities
#
include( ${CMAKE_CURRENT_LIST_DIR}/BBuildEnvQt5.cmake )

#
# OpenCV utilities
#
include( ${CMAKE_CURRENT_LIST_DIR}/BBuildEnvOpenCV.cmake )


#
# Internal macro to setup the build environment. 
#
macro( bb_build_env_setup )

  _bb_set_bbuildenv_version( 3.10.2.4 )
  message( STATUS "Setting up BBuildEnv ${BBuildEnv_VERSION}" )

  if( NOT DEFINED BBuildEnv_DISABLE_PYTHON_DETECTION )
    set( BBuildEnv_DISABLE_PYTHON_DETECTION OFF )
  endif()

  bb_check_build_type()

  if( EXISTS "${CMAKE_SOURCE_DIR}/CMakeBuild/bin" )
    # Helps migration as some detection code may still require Boost.Build python scripts.
    set( bb_script_dir "${CMAKE_SOURCE_DIR}/CMakeBuild/bin" )
  endif()
  
  if( ( NOT BBuildEnv_DISABLE_PYTHON_DETECTION ) AND ( NOT PYTHONINTERP_FOUND ) )
    find_package( PythonInterp 3 QUIET MODULE )
    if( NOT PYTHONINTERP_FOUND )
      find_package( PythonInterp MODULE )
    endif()
    if( PYTHONINTERP_FOUND )
      # message( STATUS "BBuildEnv: python interpreter found: ${PYTHON_EXECUTABLE} version ${PYTHON_VERSION_STRING}" )
    endif()
  endif()
  
  _bb_query_system_info( bb_system_info )
  # message( STATUS "bb_system_info: ${bb_system_info}" )
    
  bb_get_home_dir( bb_home_dir )
  
  _bb_find_proj_home( bb_proj_home "${bb_home_dir}" )
  
      
  # Add a cmake generator alias
  # --
  # Visual Studio 15 2017
  # Visual Studio 14 2015
  # Visual Studio 12 2013
  # Visual Studio 11 2012
  # Visual Studio 10 2010
  # --
  # Xcode
  # Unix Makefiles
  # Ninja
  # MinGW Makefiles
  # --
  unset( bb_generator_alias )
  if( CMAKE_GENERATOR STREQUAL "Unix Makefiles" )
    set( bb_generator_alias "umake" )
  elseif( CMAKE_GENERATOR STREQUAL "Xcode" )
    set( bb_generator_alias "xcode" )
  elseif( CMAKE_GENERATOR MATCHES "Visual Studio ([0-9][0-9])" )
    set( bb_generator_alias "vs${CMAKE_MATCH_1}" )
  elseif( CMAKE_GENERATOR STREQUAL "Ninja" )
    set( bb_generator_alias "ninja" )
  elseif( CMAKE_GENERATOR STREQUAL "MinGW Makefiles" )
    set( bb_generator_alias "mgwmake" )
  else()
    message( WARNING "BBuildEnv.cmake: generator '${CMAKE_GENERATOR}' is not fully supported yet, please contact technical support for further information." ) 
    #return()
    string( TOLOWER "${CMAKE_GENERATOR}" _generator_uc )
    string( REPLACE " " "_" bb_generator_alias "${_generator_uc}" )
    unset( _generator_uc )
  endif()
  #message( STATUS "bb_generator_alias: ${bb_generator_alias}" ) 
  _bb_get_cxx_compiler_version_major_minor( bb_compiler_version_major_minor )
  _bb_get_toolset_subdir( bb_toolset_subdir ${bb_compiler_version_major_minor} )
  _bb_get_platform_dir( bb_platform_dir )
  
  # set standard output directories: gcc-5.4/x86_64
  if( DEFINED bb_generator_alias )
    set( bb_default_output_dir "${bb_generator_alias}/${bb_toolset_subdir}/${bb_platform_dir}" )
  else()
    set( bb_default_output_dir "${bb_toolset_subdir}/${bb_platform_dir}" )
  endif()
  
  # the deploy folder may be used to save installer packages.
  set( bb_deploy_dir "${CMAKE_SOURCE_DIR}/deploy" )
    
  if( CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT )
    set( CMAKE_INSTALL_PREFIX "${CMAKE_SOURCE_DIR}/install" CACHE PATH "Standard install prefix" FORCE )
  endif()
  
  if( BUILD_SHARED_LIBS )
    set( _bb_shared_suffix "-shared" )
  endif()
  
  set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG          "${CMAKE_SOURCE_DIR}/bin/${bb_default_output_dir}/debug${_bb_shared_suffix}" )
  set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE        "${CMAKE_SOURCE_DIR}/bin/${bb_default_output_dir}/release${_bb_shared_suffix}" )
  set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO "${CMAKE_SOURCE_DIR}/bin/${bb_default_output_dir}/relwithdebinfo${_bb_shared_suffix}" )
  set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL     "${CMAKE_SOURCE_DIR}/bin/${bb_default_output_dir}/minsizerel${_bb_shared_suffix}" )
  
  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG          "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/debug${_bb_shared_suffix}" )
  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE        "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/release${_bb_shared_suffix}" )
  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELWITHDEBINFO "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/relwithdebinfo${_bb_shared_suffix}" )
  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_MINSIZEREL     "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/minsizerel${_bb_shared_suffix}" )
  
  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG          "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/debug${_bb_shared_suffix}" )
  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE        "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/release${_bb_shared_suffix}" )
  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELWITHDEBINFO "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/relwithdebinfo${_bb_shared_suffix}" )
  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_MINSIZEREL     "${CMAKE_SOURCE_DIR}/lib/${bb_default_output_dir}/minsizerel${_bb_shared_suffix}" )
endmacro( bb_build_env_setup )

#message( STATUS "BBuildEnv.cmake: starting: ${CMAKE_GENERATOR}" )
# Setup the build environment
bb_build_env_setup()
#message( STATUS "BBuildEnv.cmake: leaving" )

